from hub import port, motion_sensor
import runloop, motor, motor_pair, time
motor_pair.pair(motor_pair.PAIR_1, port.E, port.C)

# STRAIGHT LINE CODE START (SLC) move_straight_for_time(4000) <-- Pres Ctrl+Left_Arrow twice to copy sample.
motion_sensor.reset_yaw

async def move_straight_for_time(duration:int, speed:int=400, direction:int=1, reference_yaw:int|None=None, correction_speed:float=0.7):

    """

    Moves FRONT or BACK for specific TIME

    PARAMETERS

    -

    duration ( Integer ) --> REQUIRED

        Milisecond time for moving

    speed ( Integer )

        Default = 400

    direction ( Integer )

        Default = 1 [FORWARD]

    reference_yaw ( Integer )

        Default = None [Uses CURRENT]

    correction_speed ( Float )

        Default = 0.7

        LOWER makes SLOW TURN, more prone to FALLING OFF PATH.

        HIGHER makes FASTER but LESS ACCURATE correction.

    await move_straight_for_time(1500)

    -

    ^ A 4 second sample movement code set to defaults

    """

    tick_until = time.ticks_ms() + duration

    if reference_yaw == None:

        reference_yaw = motion_sensor.tilt_angles()[0]

    while time.ticks_ms() < tick_until:

        current_yaw = motion_sensor.tilt_angles()[0]

        correction = int((reference_yaw - current_yaw) * correction_speed)

        motor_speed = speed * direction - correction

        motor.run(port.C, motor_speed*-1)

        motor.run(port.E, motor_speed)

        await runloop.sleep_ms(10)

    motor.stop(port.C)

    motor.stop(port.E)

# PRECISE TURNING CODE (PTS)

async def turning_for_degree(degree:int, speed:int=200, ref_yaw:int|None=None, correction_factor:float=0.1, tolerance=2):

    """

    Turning for given degree and direction.

    Parameters

    ----------

    degree : int

        decidegree for turning.

        Positive range mean clockwise turning. (yaw will goes negative)

        Negative range mean counter clockwise turning. (yaw will goes positive)

        Turning angle should less than 180 degree, for both direction.

        Range: -1800 to 1800

    speed : int, optional

        moving speed.

        Default: 200

    ref_yaw : int|None, optional

        Target yaw. If not given, current yaw will use.

        If 0 given, robot align to first position angle.

        Default: None, current yaw

    correction_factor : float, optional

        Tunning parameter for amount of control.

        Default:0.2

    Raises

    ------

    ValueError

        If degree is not in range -1800to1800

    """

    if abs(degree) > 1800:

        raise ValueError

    if degree > 0:

        turning_direction = -1

    else:

        turning_direction = 1

    if ref_yaw == None:

        ref_yaw = motion_sensor.tilt_angles()[0]

    # Change from -180to180 to 0to360

    ref_yaw = (ref_yaw - 3600) % 3600

    target_yaw = (ref_yaw - degree) % 3600

    while True:

        angle_diff = abs(abs((motion_sensor.tilt_angles()[0] - 3600)%3600) - abs(target_yaw))

        #motor.run(port.C, speed * turning_direction)

        #motor.run(port.E, speed * turning_direction)

        if angle_diff > 100:

            motor.run(port.C, speed * turning_direction)

            motor.run(port.E, speed * turning_direction)

        else:

            motor.run(port.C, int(speed * turning_direction * correction_factor))

            motor.run(port.E, int(speed * turning_direction * correction_factor))

        if angle_diff <= tolerance:

            break

        await runloop.sleep_ms(1)

    motor.stop(port.C)

    motor.stop(port.E)

def cur_yaw_topview():

    return motion_sensor.tilt_angles()[0] * -1

def cur_yaw_in_3600():

    return (cur_yaw_topview() + 3600) % 3600

async def turning_for_degree_v2(degree:int, speed:int=200, ref_yaw:int|None=None, turning_direction:int=1, speed_reduce_angle_diff:int=100, speed_reduce_ratio:float=0.1, tolerance=2):

    """

    Turning for given degree and direction.

    Parameters

    ----------

    degree : int

        decidegree for turning.

        Positive range mean clockwise turning. (yaw from tilt_angles() will goes negative)

        Negative range mean counter clockwise turning. (yaw from tilt_angles() will goes positive)

        Range: -3600 to 3600

    speed : int, optional

        moving speed.

        Default: 200

    ref_yaw : int|None, optional

        If not given, current yaw will use.

        If 0 given, robot align to first position angle when it power on.

        Range: 0 to 3600

        Default: None, current yaw

    turning_direction : int, optional

        Default turning direction. It will changed by degree value.

        1 mean counter clockwise turning

        -1 mean clockwise turning

        Default: 1

    speed_reduce_angle_diff : int, optional

        Tuning parameter of speed reducing beginning angle diff to target yaw.

        Default: 100

    speed_reduce_ratio : float, optional

        Tunning parameter of speed reducing ration near target yaw.

        Default: 0.2

    tolerance : int, optional

        Stop condition tolerance of angle diff.

        Default : 2

    Raises

    ------

    ValueError

        If degree is not in range -3600 to 3600

    """

    if abs(degree) > 3600:

        raise ValueError

    # Depends on motor position

    if degree >= 0:

        turning_direction *= -1

    else:

        turning_direction *= 1

    if ref_yaw == None:

        ref_yaw = cur_yaw_in_3600()

    target_yaw = (ref_yaw + degree) % 3600

    while True:

        angle_diff = abs(target_yaw - cur_yaw_in_3600())

        if angle_diff <= tolerance:

            motor.stop(port.C)

            motor.stop(port.E)

            break

        if angle_diff > speed_reduce_angle_diff:

            motor.run(port.C, speed * turning_direction)

            motor.run(port.E, speed * turning_direction)

        else:

            motor.run(port.C, int(speed * turning_direction * speed_reduce_ratio))

            motor.run(port.E, int(speed * turning_direction * speed_reduce_ratio))

        await runloop.sleep_ms(1)


async def main():
    await motor.run_for_degrees(port.A, -72, 870) # Move arm to start position
    await move_straight_for_time(1105, 850, 1, None, 1) # Move forward to mission 6
    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 52, 70, -70) # Turn to face the mission
    await motor_pair.move_for_degrees(motor_pair.PAIR_1, -20, 0)
    await motor.run_for_degrees(port.A, -100, 470) # Move arm to do the mission
    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 110, 0, velocity=670) # Back away
    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, -57, 200, -167) # Turn to face mission 5
    await motor.run_for_degrees(port.A, 167, 670) # Move arm to start position
    await motor_pair.move_for_degrees(motor_pair.PAIR_1, -130, 0, velocity=670) # Move forward to mission 5
    await motor.run_for_degrees(port.A, -170, 367) # Move arm to do the mission
    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 77, 0, velocity=670) # Back up a little
    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 67, -100, 100) # Turn to get ready to go home
    await move_straight_for_time(1167, 850, -1, None, 1) # Move back to home
    motor.run_for_degrees(port.A, 165, 870) # Move arm to back position
    print("hi")
runloop.run(main())
